<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Geometry Defender: Warp Edition</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }
        h2 { margin: 10px 0; text-shadow: 0 0 10px #4ecca3; z-index: 10; }
        
        #gameCanvas {
            background: transparent; /* Achtergrond wordt nu door JS getekend */
            border: 4px solid #4ecca3;
            box-shadow: 0 0 30px rgba(78, 204, 163, 0.3);
            border-radius: 4px;
            display: none;
        }
        
        /* UI Elementen */
        #ui {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 18px;
            align-items: center;
            display: none;
            z-index: 10;
        }
        .ammo-type {
            padding: 5px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.5);
            opacity: 0.5;
            transition: all 0.1s;
            position: relative;
            min-width: 100px;
            text-align: center;
        }
        .active {
            opacity: 1;
            font-weight: bold;
            border-color: white;
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor;
            z-index: 10;
        }
        
        #lives { color: #ff4757; font-weight: bold; text-shadow: 0 0 5px red; }

        /* MENU STIJLEN */
        .overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            padding: 40px;
            border: 4px solid #4ecca3;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 50px rgba(78, 204, 163, 0.3);
            z-index: 100;
            min-width: 300px;
        }
        
        .mode-btn {
            display: block;
            width: 100%;
            margin: 15px 0;
            padding: 20px;
            font-size: 22px;
            background: #1a1a2e;
            color: #4ecca3;
            border: 2px solid #4ecca3;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
        }
        .mode-btn:hover {
            background: #4ecca3;
            color: #000;
            transform: scale(1.05);
        }
        
        h1 { margin-top: 0; color: #4ecca3; }
        
        #game-over { display: none; border-color: #ff4757; }
        .restart-btn { background: #ff4757; color: white; border: none; }
        .restart-btn:hover { background: #ff6b81; }

    </style>
</head>
<body>

    <h2>Geometry Defender</h2>
    
    <div id="main-menu" class="overlay-screen">
        <h1>Kies Missie</h1>
        <button class="mode-btn" onclick="startGame('hoeken')">1. Hoeken Jagen</button>
        <button class="mode-btn" onclick="startGame('driehoeken')">2. Driehoeken Squad</button>
    </div>

    <div id="game-over" class="overlay-screen">
        <h1 style="color: #ff4757;">GAME OVER</h1>
        <p style="font-size: 24px;">Score: <span id="final-score">0</span></p>
        <p>Moeilijkheidsgraad bereikt: <span id="final-diff">0</span>%</p>
        <button class="mode-btn restart-btn" onclick="location.reload()">Hoofdmenu</button>
    </div>

    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div id="lives">Levens: ❤️❤️❤️❤️</div>
        
        <div id="ui-1" class="ammo-type">1</div>
        <div id="ui-2" class="ammo-type">2</div>
        <div id="ui-3" class="ammo-type">3</div>
        <div id="ui-4" class="ammo-type">4</div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
/* --- AUDIO SYSTEEM --- */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if (type === 'shoot') {
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'hit') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'damage') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
    }
}

/* --- GAME DATA --- */
const GAME_MODES = {
    'hoeken': {
        name: 'Hoeken',
        types: {
            'type1': { label: 'Scherp', color: '#2ecc71', logic: 'angle', min: 15, max: 85 },
            'type2': { label: 'Recht', color: '#3498db', logic: 'angle', min: 90, max: 90 },
            'type3': { label: 'Stomp', color: '#e67e22', logic: 'angle', min: 95, max: 175 },
            'type4': { label: 'Gestrekt', color: '#9b59b6', logic: 'angle', min: 180, max: 180 }
        }
    },
    'driehoeken': {
        name: 'Driehoeken',
        types: {
            'type1': { label: 'Gelijkzijdig', color: '#f1c40f', logic: 'triangle_eq' },
            'type2': { label: 'Gelijkbenig', color: '#e67e22', logic: 'triangle_iso' },
            'type3': { label: 'Rechthoekig', color: '#3498db', logic: 'triangle_right' },
            'type4': { label: 'Willekeurig', color: '#ecf0f1', logic: 'triangle_random' }
        }
    }
};

/* --- VARIABELEN --- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let currentMode = null;
let currentTypes = {};
let score = 0;
let lives = 4;
let isGameOver = false;
let isRunning = false;
let gameFrame = 0;
let difficultyFactor = 0; // 0.0 tot 1.0 (en hoger)

let player = { x: 400, y: 550, width: 40, height: 40, color: '#fff', type: 'type1' };
let bullets = [];
let enemies = [];
let particles = [];
let stars = [];

// Maak meer sterren voor warp effect
for(let i=0; i<80; i++) {
    stars.push({
        x: Math.random() * canvas.width, 
        y: Math.random() * canvas.height,
        size: Math.random() * 2 + 0.5, 
        speed: Math.random() * 3 + 1
    });
}

/* --- FUNCTIES --- */

function startGame(modeKey) {
    currentMode = GAME_MODES[modeKey];
    currentTypes = currentMode.types;
    
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('ui').style.display = 'flex';
    
    setupUIButtons();
    player.type = 'type1';
    switchWeapon('type1');
    
    if (!isRunning) {
        isRunning = true;
        animate();
    }
}

function setupUIButtons() {
    let i = 1;
    for (let key in currentTypes) {
        let el = document.getElementById('ui-' + i);
        let data = currentTypes[key];
        el.innerText = i + ". " + data.label;
        el.style.backgroundColor = data.color;
        el.style.color = '#000';
        el.style.borderColor = "#555";
        i++;
    }
}

function switchWeapon(typeKey) {
    player.type = typeKey;
    player.color = currentTypes[typeKey].color;
    for(let i=1; i<=4; i++) {
        document.getElementById('ui-'+i).classList.remove('active');
        document.getElementById('ui-'+i).style.borderColor = "#555";
    }
    let index = typeKey.replace('type', '');
    let activeEl = document.getElementById('ui-' + index);
    activeEl.classList.add('active');
    activeEl.style.borderColor = "white";
}

/* --- CLASSES --- */

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.size = Math.random() * 3 + 2;
        this.speedX = Math.random() * 4 - 2;
        this.speedY = Math.random() * 4 - 2;
    }
    update() { this.x += this.speedX; this.y += this.speedY; this.size -= 0.1; }
    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
}

class Enemy {
    constructor() {
        this.x = Math.random() * (canvas.width - 70) + 10;
        this.y = -70;
        this.size = 50;
        
        // Base snelheid + moeilijkheidsgraad
        // Hoe hoger de score, hoe sneller ze vallen
        this.speed = (Math.random() * 1.5 + 1) + (difficultyFactor * 3); 
        
        const keys = Object.keys(currentTypes);
        this.typeKey = keys[Math.floor(Math.random() * keys.length)];
        this.data = currentTypes[this.typeKey];
        
        /* --- PROCEDURAL GENERATION --- */
        // We genereren nu random coördinaten voor unieke driehoeken
        if (this.data.logic === 'angle') {
            if (this.data.min === this.data.max) this.angle = this.data.min;
            else this.angle = Math.floor(Math.random() * (this.data.max - this.data.min + 1) + this.data.min);
        } else {
            // Basis punten (links-onder en rechts-onder) staan vast t.o.v. x/y
            // We variëren vooral punt 1 (de top)
            this.p1 = {x: 0, y: 0};
            this.p2 = {x: 0, y: this.size};
            this.p3 = {x: this.size, y: this.size};
            
            if (this.data.logic === 'triangle_eq') {
                // Gelijkzijdig: Altijd symmetrisch, maar we kunnen hem een beetje kantelen of schalen
                this.p1.x = this.size / 2;
                this.p1.y = 0; 
            }
            else if (this.data.logic === 'triangle_iso') {
                // Gelijkbenig: P1 zit in het midden (x = size/2)
                // Maar de hoogte (y) is willekeurig! (smal/lang of breed/laag)
                this.p1.x = this.size / 2;
                // Random hoogte tussen 0.5x en 2x de breedte, maar niet gelijkzijdig
                let randomHeight = Math.random() * this.size * 1.5 + 20;
                // Zorg dat hij niet per ongeluk gelijkzijdig lijkt (hoogte ~43)
                if (Math.abs(randomHeight - 43) < 10) randomHeight += 20; 
                this.p1.y = this.size - randomHeight;
            }
            else if (this.data.logic === 'triangle_right') {
                // Rechthoekig: P1 zit recht boven P2 OF recht boven P3
                if (Math.random() < 0.5) {
                    this.p1.x = 0; // Links recht
                } else {
                    this.p1.x = this.size; // Rechts recht
                }
                // Random hoogte
                this.p1.y = this.size - (Math.random() * this.size + 20);
            }
            else if (this.data.logic === 'triangle_random') {
                // Willekeurig: P1 mag NIET in het midden en NIET boven de hoeken
                // X tussen 20% en 80%, maar niet 50%
                let rndX = Math.random() * 0.6 + 0.2; // 0.2 tot 0.8
                if (rndX > 0.45 && rndX < 0.55) rndX = 0.3; // Correctie midden
                this.p1.x = this.size * rndX;
                this.p1.y = this.size - (Math.random() * this.size * 1.2 + 20);
            }
        }
    }
    
    update() { this.y += this.speed; }
    
    draw() {
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        if (this.data.logic === 'angle') {
            ctx.moveTo(this.x + this.size, this.y + this.size);
            ctx.lineTo(this.x, this.y + this.size);
            const radians = (this.angle * Math.PI) / 180;
            const endX = this.x + Math.cos(radians) * this.size;
            const endY = (this.y + this.size) - Math.sin(radians) * this.size;
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.beginPath(); ctx.arc(this.x, this.y + this.size, 15, 0, -radians, true); ctx.stroke();
            
        } else {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.beginPath();
            ctx.moveTo(this.p1.x, this.p1.y);
            ctx.lineTo(this.p2.x, this.p2.y);
            ctx.lineTo(this.p3.x, this.p3.y);
            ctx.closePath();
            ctx.stroke();
            
            // Rechthoek teken bij rechthoekige driehoek
            if (this.data.logic === 'triangle_right') {
                ctx.lineWidth = 1;
                ctx.beginPath();
                let cornerSize = 10;
                // Check of de rechte hoek links of rechts zit
                if (this.p1.x === 0) { // Links
                    ctx.rect(0, this.size - cornerSize, cornerSize, cornerSize);
                } else { // Rechts
                    ctx.rect(this.size - cornerSize, this.size - cornerSize, cornerSize, cornerSize);
                }
                ctx.stroke();
            }
            ctx.restore();
        }
    }
}

/* --- CONTROLS --- */
const keys = {};
window.addEventListener('keydown', e => {
    if(isGameOver) return;
    keys[e.code] = true;
    if(e.key === '1') switchWeapon('type1');
    if(e.key === '2') switchWeapon('type2');
    if(e.key === '3') switchWeapon('type3');
    if(e.key === '4') switchWeapon('type4');
    if(e.code === 'Space') {
        bullets.push({
            x: player.x + player.width/2, y: player.y,
            type: player.type,
            color: currentTypes[player.type].color,
            speed: 10
        });
        playSound('shoot');
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

/* --- LOOP --- */
function animate() {
    if (isGameOver) return;
    
    // MOEILIJKHEID EN ACHTERGROND UPDATE
    // Factor gaat van 0.0 naar 1.0 (en hoger) naarmate score stijgt
    // Bij 500 punten is factor 1.0
    difficultyFactor = score / 500; 
    
    // Achtergrond kleur verloop: Donkerblauw naar Donkerrood
    // Blauw start: rgb(11, 11, 20)
    // Rood eind: rgb(60, 0, 0)
    let r = Math.min(60, 11 + (difficultyFactor * 50));
    let g = Math.max(0, 11 - (difficultyFactor * 11));
    let b = Math.max(0, 20 - (difficultyFactor * 20));
    
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Wis scherm met nieuwe kleur
    
    // STERREN (WARP EFFECT)
    let starSpeedMult = 1 + (difficultyFactor * 4); // Sterren gaan tot 5x sneller
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    
    stars.forEach(s => {
        s.y += s.speed * starSpeedMult; 
        if(s.y > canvas.height) s.y = 0;
        
        // Teken sterren als strepen als het sneller gaat
        let length = s.size + (difficultyFactor * 20 * s.size);
        ctx.fillRect(s.x, s.y, s.size, length);
    });
    
    // BODEM LIJN
    ctx.strokeStyle = '#ff4757'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, canvas.height-2); ctx.lineTo(canvas.width, canvas.height-2); ctx.stroke();
    
    // SPELER
    if (keys['ArrowLeft'] && player.x > 0) player.x -= (6 + difficultyFactor); // Speler ook iets sneller
    if (keys['ArrowRight'] && player.x < canvas.width - player.width) player.x += (6 + difficultyFactor);
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.moveTo(player.x + player.width/2, player.y);
    ctx.lineTo(player.x + player.width, player.y + player.height);
    ctx.lineTo(player.x + player.width/2, player.y + player.height - 10);
    ctx.lineTo(player.x, player.y + player.height);
    ctx.fill();
    
    // KOGELS
    for (let i=0; i<bullets.length; i++) {
        let b = bullets[i]; b.y -= b.speed;
        ctx.fillStyle = b.color; ctx.fillRect(b.x-3, b.y, 6, 12);
        if(b.y < 0) { bullets.splice(i,1); i--; }
    }
    
    // PARTICLES
    for(let i=0; i<particles.length; i++) {
        particles[i].update(); particles[i].draw();
        if(particles[i].size <= 0.2) { particles.splice(i,1); i--; }
    }
    
    // VIJANDEN SPAWNEN
    // Normaal elke 90 frames. Hoe moeilijker, hoe lager dit getal.
    // Minimaal elke 30 frames (anders is het onmogelijk)
    let spawnRate = Math.max(30, 90 - (difficultyFactor * 50));
    
    if (gameFrame % Math.floor(spawnRate) === 0) enemies.push(new Enemy());
    
    for (let i=0; i<enemies.length; i++) {
        let e = enemies[i]; e.update(); e.draw();
        
        // Botsing kogel
        for(let j=0; j<bullets.length; j++) {
            let b = bullets[j];
            if(b.x > e.x-10 && b.x < e.x+e.size+10 && b.y > e.y && b.y < e.y+e.size) {
                if(b.type === e.typeKey) {
                    score += 10;
                    playSound('hit');
                    for(let k=0; k<10; k++) particles.push(new Particle(e.x+20, e.y+20, e.data.color));
                    enemies.splice(i,1); bullets.splice(j,1);
                    i--; j--;
                    document.getElementById('score').innerText = score;
                } else {
                    score -= 5;
                    bullets.splice(j,1); j--;
                    for(let k=0; k<5; k++) particles.push(new Particle(b.x, b.y, '#fff'));
                }
                break;
            }
        }
        
        // Bodem
        if(e.y > canvas.height) {
            enemies.splice(i,1); i--;
            lives--;
            playSound('damage');
            document.getElementById('lives').innerText = "Levens: " + "❤️".repeat(lives);
            canvas.style.transform = "translate(5px,5px)";
            setTimeout(()=>canvas.style.transform="none", 50);
            if(lives <= 0) {
                isGameOver = true;
                document.getElementById('final-score').innerText = score;
                document.getElementById('final-diff').innerText = Math.round(difficultyFactor * 100);
                document.getElementById('game-over').style.display = 'block';
            }
        }
    }
    gameFrame++;
    requestAnimationFrame(animate);
}
</script>
</body>
</html>
