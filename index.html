<!DOCTYPE html>
<html lang="nl">

<head>
    <meta charset="UTF-8">
    <title>Geometry Defender: Endless</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        h2 {
            margin: 10px 0;
            text-shadow: 0 0 10px #4ecca3;
            z-index: 10;
        }

        #gameCanvas {
            background: transparent;
            border: 4px solid #4ecca3;
            box-shadow: 0 0 30px rgba(78, 204, 163, 0.3);
            border-radius: 4px;
            display: none;
        }

        #ui {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 18px;
            align-items: center;
            display: none;
            z-index: 10;
        }

        .ammo-type {
            padding: 5px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0.5;
            transition: all 0.1s;
            position: relative;
            min-width: 100px;
            text-align: center;
        }

        .active {
            opacity: 1;
            font-weight: bold;
            border-color: white;
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor;
            z-index: 10;
        }

        #lives {
            color: #ff4757;
            font-weight: bold;
            text-shadow: 0 0 5px red;
        }

        #target-score {
            color: #f1c40f;
            font-weight: bold;
        }

        .overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            padding: 40px;
            border: 4px solid #4ecca3;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 50px rgba(78, 204, 163, 0.3);
            z-index: 100;
            min-width: 350px;
        }

        .mode-btn {
            display: block;
            width: 100%;
            margin: 15px 0;
            padding: 20px;
            font-size: 20px;
            background: #1a1a2e;
            color: #4ecca3;
            border: 2px solid #4ecca3;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
            position: relative;
        }

        .mode-btn:hover {
            background: #4ecca3;
            color: #000;
            transform: scale(1.05);
        }

        .mode-btn.math {
            border-color: #9b59b6;
            color: #9b59b6;
        }

        .mode-btn.math:hover {
            background: #9b59b6;
            color: white;
        }

        .mode-btn.locked {
            background: #222;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            pointer-events: none;
        }

        h1 {
            margin-top: 0;
            color: #4ecca3;
        }

        #game-over {
            display: none;
            border-color: #ff4757;
        }

        #level-complete {
            display: none;
            border-color: #f1c40f;
        }

        .restart-btn {
            background: #ff4757;
            color: white;
            border: none;
        }

        .next-btn {
            background: #f1c40f;
            color: black;
            border: none;
        }

        /* NIEUWE KNOP STIJL */
        .continue-btn {
            background: #3498db;
            color: white;
            border: none;
            margin-top: 10px;
        }

        .continue-btn:hover {
            background: #2980b9;
        }

        .reset-link {
            margin-top: 20px;
            color: #555;
            font-size: 12px;
            cursor: pointer;
            text-decoration: underline;
        }
    </style>
</head>

<body>

    <h2>Geometry Defender</h2>

    <div id="main-menu" class="overlay-screen">
        <h1>Kies Missie</h1>
        <p>Haal <span style="color:#f1c40f">150 punten</span> om het volgende level te openen!</p>

        <button id="btn-lvl1" class="mode-btn" onclick="startFlow('level1')">
            1. De Aanval (Scherp/Stomp) <span id="hs-1" style="font-size:0.8em; color: #f1c40f; float:right;"></span>
        </button>

        <button id="btn-lvl2" class="mode-btn locked" onclick="startGame('level2')">
            üîí 2. Versterking (Alle Hoeken) <span id="hs-2"
                style="font-size:0.8em; color: #f1c40f; float:right;"></span>
        </button>

        <button id="btn-lvl3" class="mode-btn locked" onclick="startGame('level3')">
            üîí 3. Driehoeken <span id="hs-3" style="font-size:0.8em; color: #f1c40f; float:right;"></span>
        </button>

        <div class="reset-link" onclick="resetProgress()">[Reset Progressie]</div>

        <div style="margin-top: 30px; border-top: 1px solid #333; padding-top: 10px;">
            <p style="font-size: 14px; color: #888;">Code voor voortgang:</p>
            <input type="text" id="save-code-input" placeholder="Plak hier je code..."
                style="padding: 10px; width: 70%; background: #222; border: 1px solid #4ecca3; color: white; border-radius: 4px;">
            <div style="display: flex; gap: 10px; margin-top: 10px; justify-content: center;">
                <button class="mode-btn" style="padding: 10px; font-size: 14px; margin: 0; width: auto;"
                    onclick="exportProgress()">Voortgang opslaan üìã</button>
                <button class="mode-btn" style="padding: 10px; font-size: 14px; margin: 0; width: auto;"
                    onclick="importProgress()">Code laden üì•</button>
            </div>
        </div>
    </div>

    <div id="game-over" class="overlay-screen">
        <h1 style="color: #ff4757;">GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button class="mode-btn restart-btn" onclick="location.reload()">Probeer Opnieuw</button>
    </div>

    <div id="level-complete" class="overlay-screen">
        <h1 style="color: #f1c40f;">MISSIE VOLTOOID!</h1>
        <p>Geweldig! Het volgende level is vrijgespeeld.</p>

        <button class="mode-btn next-btn" onclick="location.reload()">Terug naar Menu</button>
        <button class="mode-btn continue-btn" onclick="continuePlaying()">Doorspelen üöÄ</button>
    </div>

    <!-- NIEUW: Story Screen -->
    <div id="story-screen" class="overlay-screen"
        style="display:none; max-width:600px; flex-direction:column; align-items:center;">
        <h1 style="color: #e74c3c;">ALARM FASE 1</h1>
        <div style="font-size: 60px;">ü´°</div>
        <p id="story-text"
            style="font-size: 20px; text-align: left; background: #222; padding: 15px; border-radius: 10px; border: 2px solid #555;">
            ...
        </p>
        <button class="mode-btn" onclick="finishStory()">Begrepen, Generaal!</button>
    </div>

    <!-- NIEUW: Instructie Scherm -->
    <div id="instruction-screen" class="overlay-screen" style="display:none; max-width:600px;">
        <h1 style="color: #4ecca3;">Uitleg: Hoeken</h1>
        <div style="display:flex; justify-content:space-around; margin: 20px 0; text-align:left; gap: 20px;">
            <div>
                <h3 style="color:#2ecc71">Scherp (< 90¬∞)</h3>
                        <p>Als een hoek kleiner is dan de hoek van een vierkant (90¬∞).</p>
                        <div
                            style="width:50px; height:50px; border-bottom: 2px solid white; border-right:2px solid white; transform: skewX(20deg);">
                        </div>
            </div>
            <div>
                <h3 style="color:#e67e22">Stomp (> 90¬∞)</h3>
                <p>Als een hoek groter is dan 90¬∞, maar kleiner dan gestrekt (180¬∞).</p>
                <div
                    style="width:50px; height:50px; border-bottom: 2px solid white; border-left:2px solid white; transform: skewX(-20deg);">
                </div>
            </div>
        </div>
        <p>Kijk goed naar de lijnen van de vijanden!</p>
        <button class="mode-btn" onclick="startPracticeMode()">Start Oefenen</button>
    </div>

    <!-- NIEUW: Oefen Scherm Overlay (voor controls) -->
    <div id="practice-overlay"
        style="position: absolute; top: 100px; left: 50%; transform: translateX(-50%); text-align: center; display: none; z-index: 50; pointer-events: none;">
        <h2 style="color:white; background:rgba(0,0,0,0.7); padding: 10px; border-radius:10px;">Oefen Modus</h2>
        <p style="background:rgba(0,0,0,0.7); padding: 10px; border-radius:10px;">
            1. Gebruik <b>toetsen 1-4</b> om het juiste type kogel te kiezen.<br>
            2. Gebruik <b>Spatie</b> om te schieten.<br>
            3. Raak de stilstaande doelen om te oefenen!<br><br>
            <i>De vijanden bewegen niet in deze modus.</i>
        </p>
    </div>

    <div id="practice-controls" style="position: absolute; bottom: 20px; right: 20px; display: none; z-index: 60;">
        <button class="mode-btn"
            style="padding: 15px 30px; font-weight:bold; background: #f1c40f; color: black; border:none;"
            onclick="startRealMission()">START NIEUWE MISSIE &raquo;</button>
    </div>

    <div id="ui">
        <div>Score: <span id="score">0</span> / <span id="target-ui">150</span></div>
        <div id="lives">Levens: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="ui-1" class="ammo-type">1</div>
        <div id="ui-2" class="ammo-type">2</div>
        <div id="ui-3" class="ammo-type">3</div>
        <div id="ui-4" class="ammo-type">4</div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        /* --- SETTINGS --- */
        const WIN_SCORE = 150;

        /* --- PROGRESSIE --- */
        let userProgress = localStorage.getItem('geoDefenderProgress') || 1;
        userProgress = parseInt(userProgress);
        let highscores = JSON.parse(localStorage.getItem('geoDefenderHighscores')) || { 1: 0, 2: 0, 3: 0 };
        let playerName = localStorage.getItem('geoDefenderPlayerName');

        if (!playerName) {
            playerName = prompt("Welkom! Wat is jouw naam, Generaal?", "Speler") || "Speler";
            localStorage.setItem('geoDefenderPlayerName', playerName);
        }

        function updateMenu() {
            if (userProgress >= 2) {
                let btn2 = document.getElementById('btn-lvl2');
                btn2.classList.remove('locked');
                btn2.innerText = "2. Versterking (Alle Hoeken)";
                addHighscoreSpan(btn2, 2);
            }
            if (userProgress >= 3) {
                let btn3 = document.getElementById('btn-lvl3');
                btn3.classList.remove('locked');
                btn3.innerText = "3. Driehoeken";
                addHighscoreSpan(btn3, 3);
            }

            // Update Scores display
            if (highscores[1] > 0) document.getElementById('hs-1').innerText = `üèÜ ${highscores[1]}`;
            if (highscores[2] > 0 && document.getElementById('hs-2')) document.getElementById('hs-2').innerText = `üèÜ ${highscores[2]}`;
            if (highscores[3] > 0 && document.getElementById('hs-3')) document.getElementById('hs-3').innerText = `üèÜ ${highscores[3]}`;
        }

        function addHighscoreSpan(btn, id) {
            let span = document.createElement('span');
            span.id = 'hs-' + id;
            span.style.fontSize = '0.8em';
            span.style.color = '#f1c40f';
            span.style.float = 'right';
            btn.appendChild(span);
        }
        updateMenu();

        function resetProgress() {
            if (confirm("Weet je zeker dat je alle voortgang wilt wissen?")) {
                localStorage.setItem('geoDefenderProgress', 1);
                localStorage.setItem('geoDefenderHighscores', JSON.stringify({ 1: 0, 2: 0 }));
                location.reload();
            }
        }

        /* --- SAVE / LOAD SYSTEM --- */
        function stringToHex(str) {
            let hex = '';
            for (let i = 0; i < str.length; i++) {
                hex += '' + str.charCodeAt(i).toString(16);
            }
            return hex;
        }

        function hexToString(hex) {
            let str = '';
            for (let i = 0; i < hex.length; i += 2) {
                str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return str;
        }

        function exportProgress() {
            let name = prompt("Wat is je naam?", playerName);
            if (name) {
                playerName = name;
                localStorage.setItem('geoDefenderPlayerName', playerName);
            } else {
                name = playerName;
            }

            // We voegen een 'salt' toe zodat de code er elke keer anders uit kan zien of gewoon wat complexer is
            const data = {
                lvl: userProgress,
                name: name,
                scores: highscores,
                salt: Math.floor(Math.random() * 10000)
            };
            const jsonStr = JSON.stringify(data);
            const hexCode = stringToHex(jsonStr);

            // Kopieer naar klembord
            navigator.clipboard.writeText(hexCode).then(() => {
                alert("Code gekopieerd naar klembord! \nBewaar deze goed: " + hexCode);
            }).catch(err => {
                prompt("Kopieer deze code handmatig:", hexCode);
            });
        }

        function importProgress() {
            const input = document.getElementById('save-code-input');
            const hexCode = input.value.trim();

            if (!hexCode) {
                alert("Vul eerst een code in!");
                return;
            }

            try {
                const jsonStr = hexToString(hexCode);
                const data = JSON.parse(jsonStr);

                if (data.lvl && typeof data.lvl === 'number' && data.lvl >= 1 && data.lvl <= 3) {
                    // VERIFICATION STEP
                    let inputName = prompt("Ter verificatie: Wat is de naam bij deze code?");
                    if (!inputName) return; // Cancelled

                    let storedName = data.name || "Speler";

                    if (inputName.trim().toLowerCase() !== storedName.trim().toLowerCase()) {
                        alert("Naam komt niet overeen met deze code.");
                        return;
                    }

                    if (confirm(`Wil je voortgang laden van ${data.name || "Onbekend"} (Level ${data.lvl})?`)) {
                        localStorage.setItem('geoDefenderProgress', data.lvl);
                        if (data.name) localStorage.setItem('geoDefenderPlayerName', data.name);
                        if (data.scores) localStorage.setItem('geoDefenderHighscores', JSON.stringify(data.scores));

                        alert(`Welkom terug, ${data.name || "Speler"}!`);
                        location.reload();
                    }
                } else {
                    throw new Error("Ongeldige data");
                }
            } catch (e) {
                alert("Ongeldige code! Probeer het opnieuw.");
            }
        }

        /* --- AUDIO --- */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            } else if (type === 'damage') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'win') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        const GAME_MODES = {
            'level1': {
                id: 1, name: 'Hoeken Aanval', speedMultiplier: 0.8,
                types: {
                    'type1': { label: 'Scherp', color: '#2ecc71', logic: 'angle', min: 15, max: 85 },
                    'type2': { label: 'Stomp', color: '#e67e22', logic: 'angle', min: 95, max: 175 }
                    // Level 1: Only Sharp & Obtuse
                }
            },
            'level2': {
                id: 2, name: 'Versterking', speedMultiplier: 1.0,
                types: {
                    'type1': { label: 'Scherp', color: '#2ecc71', logic: 'angle', min: 15, max: 85 },
                    'type2': { label: 'Stomp', color: '#e67e22', logic: 'angle', min: 95, max: 175 },
                    'type3': { label: 'Recht', color: '#3498db', logic: 'angle', min: 90, max: 90 },
                    'type4': { label: 'Gestrekt', color: '#9b59b6', logic: 'angle', min: 180, max: 180 }
                }
            },
            'level3': {
                id: 3, name: 'Driehoeken', speedMultiplier: 1.0,
                types: {
                    'type1': { label: 'Gelijkzijdig', color: '#f1c40f', logic: 'triangle_eq' },
                    'type2': { label: 'Gelijkbenig', color: '#e67e22', logic: 'triangle_iso' },
                    'type3': { label: 'Rechthoekig', color: '#3498db', logic: 'triangle_right' },
                    'type4': { label: 'Overige', color: '#ecf0f1', logic: 'triangle_random' }
                }
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let currentMode = null;
        let currentTypes = {};
        let score = 0;
        let lives = 4;
        let isGameOver = false;
        let hasWon = false; // NIEUW: Houdt bij of we al gewonnen hebben
        let isRunning = false;
        let gameFrame = 0;
        let difficultyFactor = 0;

        let player = { x: 400, y: 550, width: 40, height: 40, color: '#fff', type: 'type1' };
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];

        for (let i = 0; i < 80; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 3 + 1
            });
        }

        let isPractice = false; // NIEUW

        function startFlow(modeKey) {
            if (modeKey === 'hoeken') {
                // Show instruction first
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('instruction-screen').style.display = 'block';
                currentMode = GAME_MODES[modeKey]; // Pre-set for later
            } else {
                // Normal flow for other levels (Driehoeken)
                startGame(modeKey, false);
            }
        }

        // Override original onclicks in HTML to use startFlow instead of startGame directly?
        // Or just modify startGame. Let's make a wrapper or modify existing.
        // Users onclick="startGame('hoeken')" -> We can change that in HTML or handle it here.
        // Let's change the onclick in HTML for 'hoeken' to 'startFlow'. 

        function startPracticeMode() {
            document.getElementById('instruction-screen').style.display = 'none';
            document.getElementById('practice-overlay').style.display = 'block';
            document.getElementById('practice-controls').style.display = 'block';
            startGame('hoeken', true);
        }

        function startRealMission() {
            isPractice = false;
            document.getElementById('practice-overlay').style.display = 'none';
            document.getElementById('practice-controls').style.display = 'none';

            // Reset game partially
            enemies = [];
            bullets = [];
            particles = [];
            score = 0;
            document.getElementById('score').innerText = "0";

            // Play sound
            playSound('win'); // Just a sound to indicate start
        }

        function startGame(modeKey, practice = false) {
            currentMode = GAME_MODES[modeKey];
            currentTypes = currentMode.types;
            isPractice = practice;

            // Reset alles
            score = 0;
            lives = 4;
            hasWon = false;
            isGameOver = false;
            enemies = [];
            bullets = [];
            particles = [];

            document.getElementById('score').innerText = "0";
            document.getElementById('lives').innerText = "Levens: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è";
            document.getElementById('target-ui').innerText = WIN_SCORE;

            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('ui').style.display = 'flex';
            document.getElementById('level-complete').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';

            setupUIButtons();
            player.type = 'type1';
            switchWeapon('type1');

            // Zorg dat animate loop niet dubbel draait
            if (!isRunning) {
                isRunning = true;
                animate();
            } else {
                // Als hij al draaide maar gestopt was door gameOver, start opnieuw
                animate();
            }
        }

        function continuePlaying() {
            // Verberg win scherm
            document.getElementById('level-complete').style.display = 'none';
            // Zet game status terug
            isGameOver = false;
            // We hebben al "gewonnen", dus hasWon blijft true (zodat pop-up niet nog eens komt)
            hasWon = true;

            // Update de UI dat we nu in endless mode zitten
            document.getElementById('target-ui').innerText = "‚àû";

            // Hervat loop
            animate();
        }

        function setupUIButtons() {
            // Reset all first
            for (let j = 1; j <= 4; j++) {
                document.getElementById('ui-' + j).style.display = 'none';
            }

            let i = 1;
            for (let key in currentTypes) {
                let el = document.getElementById('ui-' + i);
                let data = currentTypes[key];
                el.innerText = i + ". " + data.label;
                el.style.backgroundColor = data.color;
                el.style.color = '#000';
                el.style.borderColor = "#555";
                el.style.display = 'block'; // Show if used
                i++;
            }
        }

        function switchWeapon(typeKey) {
            player.type = typeKey;
            player.color = currentTypes[typeKey].color;
            for (let i = 1; i <= 4; i++) {
                document.getElementById('ui-' + i).classList.remove('active');
                document.getElementById('ui-' + i).style.borderColor = "#555";
            }
            let index = typeKey.replace('type', '');
            let activeEl = document.getElementById('ui-' + index);
            activeEl.classList.add('active');
            activeEl.style.borderColor = "white";
        }

        function checkWinCondition() {
            // Check alleen als we nog NIET gewonnen hebben
            if (score >= WIN_SCORE && !hasWon) {
                hasWon = true; // We hebben de threshold bereikt

                // Save Highscore Direct on Win
                if (score > highscores[currentMode.id]) {
                    highscores[currentMode.id] = score;
                    localStorage.setItem('geoDefenderHighscores', JSON.stringify(highscores));
                }

                isGameOver = true; // Pauzeer even
                playSound('win');

                if (currentMode.id >= userProgress) {
                    let nextLevel = currentMode.id + 1;
                    if (nextLevel > 3) nextLevel = 3;
                    localStorage.setItem('geoDefenderProgress', nextLevel);
                }

                document.getElementById('level-complete').style.display = 'block';
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 3 + 2;
                this.speedX = Math.random() * 4 - 2;
                this.speedY = Math.random() * 4 - 2;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.size -= 0.1; }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }

        class Enemy {
            constructor() {
                this.x = Math.random() * (canvas.width - 90) + 20;
                this.y = -70;
                this.size = 50;

                let baseSpeed = (Math.random() * 1.5 + 1);
                this.speed = baseSpeed + (difficultyFactor * 3);

                if (isPractice) {
                    // Center vertically
                    this.y = (canvas.height / 2) - 100 + (Math.random() * 50); // Roughly center
                    this.speed = 0; // No speed
                } else {
                    this.y = -70;
                }

                const keys = Object.keys(currentTypes);
                this.typeKey = keys[Math.floor(Math.random() * keys.length)];
                this.data = currentTypes[this.typeKey];
                this.mathLabel = "";

                if (this.data.logic === 'angle') {
                    if (this.data.min === this.data.max) this.angle = this.data.min;
                    else this.angle = Math.floor(Math.random() * (this.data.max - this.data.min + 1) + this.data.min);
                } else if (this.data.logic.startsWith('triangle_')) {
                    this.p1 = { x: 0, y: 0 }; this.p2 = { x: 0, y: this.size }; this.p3 = { x: this.size, y: this.size };
                    if (this.data.logic === 'triangle_eq') { this.p1.x = this.size / 2; this.p1.y = 0; }
                    else if (this.data.logic === 'triangle_iso') {
                        this.p1.x = this.size / 2;
                        let rh = Math.random() * this.size * 1.5 + 20;
                        if (Math.abs(rh - 43) < 10) rh += 20;
                        this.p1.y = this.size - rh;
                    }
                    else if (this.data.logic === 'triangle_right') {
                        this.p1.x = (Math.random() < 0.5) ? 0 : this.size; this.p1.y = this.size - (Math.random() * this.size + 20);
                    }
                    else if (this.data.logic === 'triangle_random') {
                        let rX = Math.random() * 0.6 + 0.2;
                        if (rX > 0.45 && rX < 0.55) rX = 0.3;
                        this.p1.x = this.size * rX; this.p1.y = this.size - (Math.random() * this.size * 1.2 + 20);
                    }
                } else if (this.data.logic.startsWith('math_')) {
                    // Deleted Math Logic
                }
            }

            update() {
                if (!isPractice) {
                    this.y += this.speed;
                } else {
                    // In practice mode, enemies float gently but don't fall
                    this.y += Math.sin(Date.now() / 500) * 0.5;
                }
            }

            draw() {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;

                if (this.data.logic.startsWith('math_')) {
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.size / 2, this.y + this.size / 2, this.size * 1.2, this.size / 1.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.mathLabel, this.x + this.size / 2, this.y + this.size / 2 + 5);

                } else if (this.data.logic === 'angle') {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size, this.y + this.size);
                    ctx.lineTo(this.x, this.y + this.size);
                    const rad = (this.angle * Math.PI) / 180;
                    ctx.lineTo(this.x + Math.cos(rad) * this.size, (this.y + this.size) - Math.sin(rad) * this.size);
                    ctx.stroke();
                    ctx.beginPath(); ctx.arc(this.x, this.y + this.size, 15, 0, -rad, true); ctx.stroke();

                } else {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.beginPath();
                    ctx.moveTo(this.p1.x, this.p1.y);
                    ctx.lineTo(this.p2.x, this.p2.y);
                    ctx.lineTo(this.p3.x, this.p3.y);
                    ctx.closePath();
                    ctx.stroke();
                    if (this.data.logic === 'triangle_right') {
                        ctx.lineWidth = 1; ctx.beginPath();
                        if (this.p1.x === 0) ctx.rect(0, this.size - 10, 10, 10);
                        else ctx.rect(this.size - 10, this.size - 10, 10, 10);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
        }

        const keys = {};
        window.addEventListener('keydown', e => {
            if (isGameOver) return;
            keys[e.code] = true;
            if (e.key === '1') switchWeapon('type1');
            if (e.key === '2') switchWeapon('type2');
            if (e.key === '3') switchWeapon('type3');
            if (e.key === '4') switchWeapon('type4');
            if (e.code === 'Space') {
                bullets.push({
                    x: player.x + player.width / 2, y: player.y,
                    type: player.type,
                    color: currentTypes[player.type].color,
                    speed: 10
                });
                playSound('shoot');
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        function animate() {
            if (isGameOver) return;

            difficultyFactor = score / 500;
            let r = Math.min(60, 11 + (difficultyFactor * 50));
            let g = Math.max(0, 11 - (difficultyFactor * 11));
            let b = Math.max(0, 20 - (difficultyFactor * 20));
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let starSpeedMult = 1 + (difficultyFactor * 4);

            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            stars.forEach(s => {
                s.y += s.speed * starSpeedMult;
                if (s.y > canvas.height) s.y = 0;
                let length = s.size;
                length += (difficultyFactor * 20 * s.size);
                ctx.fillRect(s.x, s.y, s.size, length);
            });

            ctx.strokeStyle = '#ff4757'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, canvas.height - 2); ctx.lineTo(canvas.width, canvas.height - 2); ctx.stroke();

            // Movement: Arrow Keys OR WASD
            if ((keys['ArrowLeft'] || keys['KeyA']) && player.x > 0) player.x -= 7;
            if ((keys['ArrowRight'] || keys['KeyD']) && player.x < canvas.width - player.width) player.x += 7;

            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height - 10);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.fill();

            for (let i = 0; i < bullets.length; i++) {
                let b = bullets[i]; b.y -= b.speed;
                ctx.fillStyle = b.color; ctx.fillRect(b.x - 3, b.y, 6, 12);
                if (b.y < 0) { bullets.splice(i, 1); i--; }
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].update(); particles[i].draw();
                if (particles[i].size <= 0.2) { particles.splice(i, 1); i--; }
            }

            let spawnRate = Math.max(30, 90 - (difficultyFactor * 50));

            if (gameFrame % Math.floor(spawnRate) === 0) enemies.push(new Enemy());

            for (let i = 0; i < enemies.length; i++) {
                let e = enemies[i]; e.update(); e.draw();

                for (let j = 0; j < bullets.length; j++) {
                    let b = bullets[j];
                    if (b.x > e.x - 20 && b.x < e.x + e.size + 20 && b.y > e.y && b.y < e.y + e.size) {
                        if (b.type === e.typeKey) {
                            score += 10;
                            playSound('hit');
                            for (let k = 0; k < 10; k++) particles.push(new Particle(e.x + 20, e.y + 20, e.data.color));
                            enemies.splice(i, 1); bullets.splice(j, 1);
                            i--; j--;
                            document.getElementById('score').innerText = score;
                            // WIN CHECK
                            checkWinCondition();
                        } else {
                            score -= 5;
                            bullets.splice(j, 1); j--;
                            for (let k = 0; k < 5; k++) particles.push(new Particle(b.x, b.y, '#fff'));
                        }
                        break;
                    }
                }

                if (e.y > canvas.height) {
                    enemies.splice(i, 1); i--;
                    lives--;
                    playSound('damage');
                    document.getElementById('lives').innerText = "Levens: " + "‚ù§Ô∏è".repeat(lives);
                    canvas.style.transform = "translate(5px,5px)";
                    setTimeout(() => canvas.style.transform = "none", 50);
                    if (lives <= 0) {
                        isGameOver = true;
                        // Check highscore ALSO on Game Over (if better than previous)
                        if (score > highscores[currentMode.id]) {
                            highscores[currentMode.id] = score;
                            localStorage.setItem('geoDefenderHighscores', JSON.stringify(highscores));
                        }

                        document.getElementById('final-score').innerText = score;
                        document.getElementById('game-over').style.display = 'block';
                    }
                }
            }
            gameFrame++;
            requestAnimationFrame(animate);
        }
    </script>
</body>

</html>
