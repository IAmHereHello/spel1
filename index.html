<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Geometry Defender: Balance Edition</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }
        h2 { margin: 10px 0; text-shadow: 0 0 10px #4ecca3; z-index: 10; }
        
        #gameCanvas {
            background: transparent;
            border: 4px solid #4ecca3;
            box-shadow: 0 0 30px rgba(78, 204, 163, 0.3);
            border-radius: 4px;
            display: none;
        }
        
        #ui {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 18px;
            align-items: center;
            display: none;
            z-index: 10;
        }
        .ammo-type {
            padding: 5px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.5);
            opacity: 0.5;
            transition: all 0.1s;
            position: relative;
            min-width: 100px;
            text-align: center;
        }
        .active {
            opacity: 1;
            font-weight: bold;
            border-color: white;
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor;
            z-index: 10;
        }
        
        #lives { color: #ff4757; font-weight: bold; text-shadow: 0 0 5px red; }

        .overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            padding: 40px;
            border: 4px solid #4ecca3;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 50px rgba(78, 204, 163, 0.3);
            z-index: 100;
            min-width: 320px;
        }
        
        .mode-btn {
            display: block;
            width: 100%;
            margin: 15px 0;
            padding: 20px;
            font-size: 20px;
            background: #1a1a2e;
            color: #4ecca3;
            border: 2px solid #4ecca3;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
        }
        .mode-btn:hover { background: #4ecca3; color: #000; transform: scale(1.05); }
        .mode-btn.math { border-color: #9b59b6; color: #9b59b6; }
        .mode-btn.math:hover { background: #9b59b6; color: white; }
        
        h1 { margin-top: 0; color: #4ecca3; }
        #game-over { display: none; border-color: #ff4757; }
        .restart-btn { background: #ff4757; color: white; border: none; }
        .restart-btn:hover { background: #ff6b81; }
    </style>
</head>
<body>

    <h2>Geometry Defender</h2>
    
    <div id="main-menu" class="overlay-screen">
        <h1>Kies Missie</h1>
        <button class="mode-btn" onclick="startGame('hoeken')">1. Hoeken Herkennen (Actie)</button>
        <button class="mode-btn" onclick="startGame('driehoeken')">2. Driehoeken Zien (Actie)</button>
        <button class="mode-btn math" onclick="startGame('rekenen')">3. Rekensom (Rustig)</button>
    </div>

    <div id="game-over" class="overlay-screen">
        <h1 style="color: #ff4757;">GAME OVER</h1>
        <p style="font-size: 24px;">Score: <span id="final-score">0</span></p>
        <button class="mode-btn restart-btn" onclick="location.reload()">Hoofdmenu</button>
    </div>

    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div id="lives">Levens: ❤️❤️❤️❤️</div>
        <div id="ui-1" class="ammo-type">1</div>
        <div id="ui-2" class="ammo-type">2</div>
        <div id="ui-3" class="ammo-type">3</div>
        <div id="ui-4" class="ammo-type">4</div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if (type === 'shoot') {
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'hit') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'damage') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
    }
}

const GAME_MODES = {
    'hoeken': {
        name: 'Hoeken',
        speedMultiplier: 1.0, // Normale snelheid
        types: {
            'type1': { label: 'Scherp', color: '#2ecc71', logic: 'angle', min: 15, max: 85 },
            'type2': { label: 'Recht', color: '#3498db', logic: 'angle', min: 90, max: 90 },
            'type3': { label: 'Stomp', color: '#e67e22', logic: 'angle', min: 95, max: 175 },
            'type4': { label: 'Gestrekt', color: '#9b59b6', logic: 'angle', min: 180, max: 180 }
        }
    },
    'driehoeken': {
        name: 'Driehoeken',
        speedMultiplier: 1.0, // Normale snelheid
        types: {
            'type1': { label: 'Gelijkzijdig', color: '#f1c40f', logic: 'triangle_eq' },
            'type2': { label: 'Gelijkbenig', color: '#e67e22', logic: 'triangle_iso' },
            'type3': { label: 'Rechthoekig', color: '#3498db', logic: 'triangle_right' },
            'type4': { label: 'Willekeurig', color: '#ecf0f1', logic: 'triangle_random' }
        }
    },
    'rekenen': {
        name: 'Rekenen',
        speedMultiplier: 0.3, // HEEL TRAAG (30% van normaal)
        types: {
            'type1': { label: 'Gelijkzijdig', color: '#f1c40f', logic: 'math_eq' },
            'type2': { label: 'Gelijkbenig', color: '#e67e22', logic: 'math_iso' },
            'type3': { label: 'Rechthoekig', color: '#3498db', logic: 'math_right' },
            'type4': { label: 'Willekeurig', color: '#ecf0f1', logic: 'math_scalene' }
        }
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let currentMode = null;
let currentTypes = {};
let score = 0;
let lives = 4;
let isGameOver = false;
let isRunning = false;
let gameFrame = 0;
let difficultyFactor = 0;

let player = { x: 400, y: 550, width: 40, height: 40, color: '#fff', type: 'type1' };
let bullets = [];
let enemies = [];
let particles = [];
let stars = [];

for(let i=0; i<80; i++) {
    stars.push({
        x: Math.random() * canvas.width, 
        y: Math.random() * canvas.height,
        size: Math.random() * 2 + 0.5, 
        speed: Math.random() * 3 + 1
    });
}

function startGame(modeKey) {
    currentMode = GAME_MODES[modeKey];
    currentTypes = currentMode.types;
    
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('ui').style.display = 'flex';
    
    setupUIButtons();
    player.type = 'type1';
    switchWeapon('type1');
    
    if (!isRunning) {
        isRunning = true;
        animate();
    }
}

function setupUIButtons() {
    let i = 1;
    for (let key in currentTypes) {
        let el = document.getElementById('ui-' + i);
        let data = currentTypes[key];
        el.innerText = i + ". " + data.label;
        el.style.backgroundColor = data.color;
        el.style.color = '#000';
        el.style.borderColor = "#555";
        i++;
    }
}

function switchWeapon(typeKey) {
    player.type = typeKey;
    player.color = currentTypes[typeKey].color;
    for(let i=1; i<=4; i++) {
        document.getElementById('ui-'+i).classList.remove('active');
        document.getElementById('ui-'+i).style.borderColor = "#555";
    }
    let index = typeKey.replace('type', '');
    let activeEl = document.getElementById('ui-' + index);
    activeEl.classList.add('active');
    activeEl.style.borderColor = "white";
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.size = Math.random() * 3 + 2;
        this.speedX = Math.random() * 4 - 2;
        this.speedY = Math.random() * 4 - 2;
    }
    update() { this.x += this.speedX; this.y += this.speedY; this.size -= 0.1; }
    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
}

class Enemy {
    constructor() {
        this.x = Math.random() * (canvas.width - 90) + 20;
        this.y = -70;
        this.size = 50;
        
        // SNELHEID AANGEPAST OP MODUS
        // In Rekenmodus is currentMode.speedMultiplier 0.3, dus ze vallen heel traag.
        let baseSpeed = (Math.random() * 1.5 + 1);
        
        if (currentMode.name === 'Rekenen') {
            // Constante trage snelheid, wordt nauwelijks sneller door difficulty
            this.speed = 0.4 + (difficultyFactor * 0.2); 
        } else {
            // Normale actie snelheid
            this.speed = baseSpeed + (difficultyFactor * 3);
        }
        
        const keys = Object.keys(currentTypes);
        this.typeKey = keys[Math.floor(Math.random() * keys.length)];
        this.data = currentTypes[this.typeKey];
        this.mathLabel = "";
        
        // --- LOGICA ---
        if (this.data.logic === 'angle') {
            if (this.data.min === this.data.max) this.angle = this.data.min;
            else this.angle = Math.floor(Math.random() * (this.data.max - this.data.min + 1) + this.data.min);
            
        } else if (this.data.logic.startsWith('triangle_')) {
            this.p1 = {x: 0, y: 0}; this.p2 = {x: 0, y: this.size}; this.p3 = {x: this.size, y: this.size};
            if (this.data.logic === 'triangle_eq') { this.p1.x = this.size/2; this.p1.y = 0; }
            else if (this.data.logic === 'triangle_iso') { 
                this.p1.x = this.size/2; 
                let rh = Math.random() * this.size * 1.5 + 20;
                if (Math.abs(rh - 43) < 10) rh += 20;
                this.p1.y = this.size - rh;
            }
            else if (this.data.logic === 'triangle_right') { 
                this.p1.x = (Math.random()<0.5)?0:this.size; this.p1.y = this.size - (Math.random()*this.size + 20); 
            }
            else if (this.data.logic === 'triangle_random') { 
                let rX = Math.random()*0.6 + 0.2; 
                if (rX>0.45 && rX<0.55) rX=0.3; 
                this.p1.x = this.size*rX; this.p1.y = this.size - (Math.random()*this.size*1.2 + 20); 
            }
            
        } else if (this.data.logic.startsWith('math_')) {
            // --- AANGEPASTE REKEN MODUS: MOOIE GETALLEN ---
            let a, b, c;
            
            // Helper functie: Rond af op 5 (bijv 32 -> 35, 41 -> 40)
            const round5 = (num) => Math.round(num / 5) * 5;
            
            if (this.data.logic === 'math_eq') {
                a = 60; b = 60; c = 60;
            } else if (this.data.logic === 'math_iso') {
                // Basis hoeken 30, 35, 40... tot 80
                let base = (Math.floor(Math.random() * 10) + 6) * 5; 
                if (base === 60) base = 50; // Voorkom 60
                if (base === 45) base = 50; // Voorkom 45-45-90
                a = base; b = base; c = 180 - (a+b);
            } else if (this.data.logic === 'math_right') {
                a = 90;
                // Scherpe hoek 20, 25... 60
                b = (Math.floor(Math.random() * 8) + 4) * 5; 
                c = 180 - a - b;
            } else {
                // Willekeurig
                do {
                    a = (Math.floor(Math.random() * 12) + 4) * 5; // 20-80
                    b = (Math.floor(Math.random() * 12) + 4) * 5;
                    c = 180 - a - b;
                } while (a===b || b===c || a===c || a===90 || b===90 || c===90 || c <= 0);
            }
            
            let nums = [a, b, c];
            // Verberg er eentje (random)
            let hideIdx = Math.floor(Math.random() * 3);
            let display = [...nums];
            display[hideIdx] = "?";
            
            this.mathLabel = `${display[0]}°, ${display[1]}°, ${display[2]}`;
        }
    }
    
    update() { this.y += this.speed; }
    
    draw() {
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        
        if (this.data.logic.startsWith('math_')) {
            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.ellipse(this.x + this.size/2, this.y + this.size/2, this.size*1.2, this.size/1.8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.mathLabel, this.x + this.size/2, this.y + this.size/2 + 5);
            
        } else if (this.data.logic === 'angle') {
            ctx.beginPath();
            ctx.moveTo(this.x + this.size, this.y + this.size);
            ctx.lineTo(this.x, this.y + this.size);
            const rad = (this.angle * Math.PI) / 180;
            ctx.lineTo(this.x + Math.cos(rad) * this.size, (this.y + this.size) - Math.sin(rad) * this.size);
            ctx.stroke();
            ctx.beginPath(); ctx.arc(this.x, this.y + this.size, 15, 0, -rad, true); ctx.stroke();
            
        } else {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.beginPath();
            ctx.moveTo(this.p1.x, this.p1.y);
            ctx.lineTo(this.p2.x, this.p2.y);
            ctx.lineTo(this.p3.x, this.p3.y);
            ctx.closePath();
            ctx.stroke();
            if (this.data.logic === 'triangle_right') {
                ctx.lineWidth = 1; ctx.beginPath();
                if (this.p1.x === 0) ctx.rect(0, this.size - 10, 10, 10);
                else ctx.rect(this.size - 10, this.size - 10, 10, 10);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
}

const keys = {};
window.addEventListener('keydown', e => {
    if(isGameOver) return;
    keys[e.code] = true;
    if(e.key === '1') switchWeapon('type1');
    if(e.key === '2') switchWeapon('type2');
    if(e.key === '3') switchWeapon('type3');
    if(e.key === '4') switchWeapon('type4');
    if(e.code === 'Space') {
        bullets.push({
            x: player.x + player.width/2, y: player.y,
            type: player.type,
            color: currentTypes[player.type].color,
            speed: 10
        });
        playSound('shoot');
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

function animate() {
    if (isGameOver) return;
    
    difficultyFactor = score / 500; 
    let r = Math.min(60, 11 + (difficultyFactor * 50));
    let g = Math.max(0, 11 - (difficultyFactor * 11));
    let b = Math.max(0, 20 - (difficultyFactor * 20));
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height); 
    
    // Sterren effect
    let starSpeedMult = 1 + (difficultyFactor * 4);
    if (currentMode.name === 'Rekenen') starSpeedMult = 0.5; // Rustige sterren in reken modus
    
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    stars.forEach(s => {
        s.y += s.speed * starSpeedMult; 
        if(s.y > canvas.height) s.y = 0;
        let length = s.size;
        if (currentMode.name !== 'Rekenen') length += (difficultyFactor * 20 * s.size);
        ctx.fillRect(s.x, s.y, s.size, length);
    });
    
    ctx.strokeStyle = '#ff4757'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, canvas.height-2); ctx.lineTo(canvas.width, canvas.height-2); ctx.stroke();
    
    if (keys['ArrowLeft'] && player.x > 0) player.x -= 7;
    if (keys['ArrowRight'] && player.x < canvas.width - player.width) player.x += 7;
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.moveTo(player.x + player.width/2, player.y);
    ctx.lineTo(player.x + player.width, player.y + player.height);
    ctx.lineTo(player.x + player.width/2, player.y + player.height - 10);
    ctx.lineTo(player.x, player.y + player.height);
    ctx.fill();
    
    for (let i=0; i<bullets.length; i++) {
        let b = bullets[i]; b.y -= b.speed;
        ctx.fillStyle = b.color; ctx.fillRect(b.x-3, b.y, 6, 12);
        if(b.y < 0) { bullets.splice(i,1); i--; }
    }
    
    for(let i=0; i<particles.length; i++) {
        particles[i].update(); particles[i].draw();
        if(particles[i].size <= 0.2) { particles.splice(i,1); i--; }
    }
    
    // SPAWN RATE
    // In Rekenmodus spawn je MINDER vaak (om de 180 frames = 3 sec ongeveer)
    let spawnRate = Math.max(30, 90 - (difficultyFactor * 50));
    if (currentMode.name === 'Rekenen') spawnRate = 180; // Rustige spawn
    
    if (gameFrame % Math.floor(spawnRate) === 0) enemies.push(new Enemy());
    
    for (let i=0; i<enemies.length; i++) {
        let e = enemies[i]; e.update(); e.draw();
        
        for(let j=0; j<bullets.length; j++) {
            let b = bullets[j];
            if(b.x > e.x-20 && b.x < e.x+e.size+20 && b.y > e.y && b.y < e.y+e.size) {
                if(b.type === e.typeKey) {
                    score += 10;
                    playSound('hit');
                    for(let k=0; k<10; k++) particles.push(new Particle(e.x+20, e.y+20, e.data.color));
                    enemies.splice(i,1); bullets.splice(j,1);
                    i--; j--;
                    document.getElementById('score').innerText = score;
                } else {
                    score -= 5;
                    bullets.splice(j,1); j--;
                    for(let k=0; k<5; k++) particles.push(new Particle(b.x, b.y, '#fff'));
                }
                break;
            }
        }
        
        if(e.y > canvas.height) {
            enemies.splice(i,1); i--;
            lives--;
            playSound('damage');
            document.getElementById('lives').innerText = "Levens: " + "❤️".repeat(lives);
            canvas.style.transform = "translate(5px,5px)";
            setTimeout(()=>canvas.style.transform="none", 50);
            if(lives <= 0) {
                isGameOver = true;
                document.getElementById('final-score').innerText = score;
                document.getElementById('game-over').style.display = 'block';
            }
        }
    }
    gameFrame++;
    requestAnimationFrame(animate);
}
</script>
</body>
</html>
